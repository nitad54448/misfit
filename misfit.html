<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Misfit Le Bail Fit (GSAS Profile 4)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --primary-accent-hover: #2563eb;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        
        #controls-panel { 
            width: 350px; min-width: 250px; max-width: 600px; flex-shrink: 0; 
            padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); 
            color: var(--text-medium); display: flex; flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
        }
        
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        
        #results-area { 
            flex-grow: 1; position: relative; background-color: #ffffff; 
            min-width: 0; display: flex; flex-direction: column; 
            padding: 1.5rem; color: var(--medium-bg);
            z-index: 10;
        }
         #results-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 0;
        }
        
        .control-group { 
            border-top: 1px solid var(--border-color); 
            padding-top: 1rem; 
            display: flex;
            flex-direction: column;
            gap: 1rem; /* This adds spacing between all items in a control group */
        }

        .control-group > * {
    margin: 0;
}

#controls-panel > .control-group:first-child {
    margin-bottom: 1.5rem;
}


        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        
        .control-input { text-align: left; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.375rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box;}
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .control-input:disabled { background-color: #272f3d; cursor: not-allowed; }
        
        .btn { padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s; cursor: pointer; border: none; text-align: center; font-size: 1rem; }

        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--border-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #6b7280; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }
        
        .file-input-label { display: block; padding: 0.75rem 1rem; background-color: var(--border-color); color: var(--text-medium); border-radius: 0.375rem; text-align: center; cursor: pointer; transition: background-color 0.2s;}
        .file-input-label:hover { background-color: #6b7280; }
        
        .results-grid { display: grid; grid-template-columns: repeat(3, minmax(90px, 1fr)); gap: 0.75rem; }
        .result-card { background-color: var(--medium-bg); padding: 0.5rem; border-radius: 0.5rem; text-align: center; transition: background 0.1s linear; }
        .result-card-label { font-size: 0.75rem; color: var(--text-dark); }
        .result-card-value { font-size: 1.0rem; font-weight: 600; color: var(--text-light); }
        
        .fit-checkbox, .constraint-checkbox { -webkit-appearance: none; appearance: none; background-color: var(--border-color); width: 1.25rem; height: 1.25rem; border: 1px solid #6b7280; border-radius: 0.25rem; cursor: pointer; display: inline-block; position: relative; }
        .fit-checkbox:checked, .constraint-checkbox:checked { background-color: var(--primary-accent); border-color: var(--primary-accent); }
        .fit-checkbox:checked::after, .constraint-checkbox:checked::after { content: '✓'; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 0.9rem; }
        
        .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); }
        .tab-btn { flex: 1; padding: 0.75rem 0.5rem; background: none; border: none; color: var(--text-dark); font-weight: 600; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; font-size: 0.9rem; }
        .tab-btn:hover { color: var(--text-light); }
        .tab-btn.active { color: var(--primary-accent); border-bottom-color: var(--primary-accent); }
        
        .tab-content-panels { padding-top: 1.5rem; }
        .tab-content-panel { display: none; flex-direction: column; gap: 1.5rem;}
        .tab-content-panel.active { display: flex; }

        .bottom-actions { margin-top: auto; padding-top: 1.5rem; }

        .slider-value-track { display: grid; grid-template-columns: 1fr; grid-template-rows: 1fr; align-items: center; }
        .slider-value-track > * { grid-column: 1; grid-row: 1; }
        .slider-value-display { text-align: center; color: var(--text-medium); font-weight: 500; font-size: 0.875rem; pointer-events: none; }
        input[type="range"].custom-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 36px; background: var(--light-bg); border-radius: 8px; outline: none; padding: 0; margin: 0; }
        input[type="range"].custom-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 22px; height: 22px; background: var(--primary-accent); border-radius: 50%; cursor: pointer; border: 3px solid var(--dark-bg); box-sizing: border-box; }
        input[type="range"].custom-slider::-moz-range-thumb { width: 22px; height: 22px; background: var(--primary-accent); border-radius: 50%; cursor: pointer; border: 3px solid var(--dark-bg); box-sizing: border-box }
        input[type="range"].custom-slider:disabled { background: #272f3d; }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { background: #6b7280; }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { background: #6b7280; }

        .control-group h2, .profile-section-header {
            margin: 0; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color);
            color: var(--text-light); font-size: 1rem; font-weight: 600;
        }

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; gap: 1rem; align-items: center;
        }
        .parameter-grid-3col { grid-template-columns: minmax(100px, auto) 1fr auto; }
        .parameter-grid-2col, .slider-group, .form-row { grid-template-columns: minmax(100px, auto) 1fr; }
        
        #lattice-parameters-container-p1, 
        #lattice-parameters-container-p2 {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { grid-column: 2; }
        .parameter-grid-3col > .control-input { grid-column: 2; }
        .parameter-grid-3col > .fit-checkbox { grid-column: 3; justify-self: center; }

        #profile-controls-container {
            display: grid; grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 1.25rem 1rem; align-items: center;
        }
        #profile-controls-container > .control-label { grid-column: 1; text-align: left; margin-bottom: 0; }
        #profile-controls-container > input[type="number"] { grid-column: 2; }
        #profile-controls-container > input[type="checkbox"] { grid-column: 3; justify-self: center; }
        #profile-controls-container > .profile-section-header { grid-column: 1 / -1; }
        
        .help-tooltip-container { position: relative; display: inline-block; }
        .help-icon { display: flex; align-items: center; justify-content: center; width: 28px; height: 28px; background-color: var(--border-color); color: var(--text-light); border-radius: 50%; font-weight: bold; font-size: 1rem; cursor: help; transition: background-color: 0.2s; }
        .help-icon:hover { background-color: #6b7280; }
        
        .tooltip-content {
            visibility: hidden; opacity: 0; width: 300px;
            background-color: var(--light-bg); color: var(--text-medium); text-align: left;
            border-radius: 0.375rem; padding: 1rem;
            position: absolute; z-index: 1001;
            top: -15px; right: 115%; margin-right: 10px;
            transition: opacity 0.3s; font-size: 0.8rem; border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        .tooltip-content::after {
            content: ""; position: absolute;
            top: 20px; left: 100%; margin-top: -5px; 
            border-width: 5px; border-style: solid;
            border-color: transparent transparent transparent var(--light-bg);
        }
        .help-tooltip-container:hover .tooltip-content { visibility: visible; opacity: 1; }
        .tooltip-content h4 { color: var(--text-light); font-size: 0.9rem; margin-top: 0; margin-bottom: 0.5rem; font-weight: 600; }
        .tooltip-content p { margin-top: 0; margin-bottom: 0.75rem; line-height: 1.4; }
        .tooltip-content hr { border: none; border-top: 1px solid var(--border-color); margin: 0.75rem 0; }
        .hidden { display: none !important; }

        #controls-panel::-webkit-scrollbar { width: 6px; }
        #controls-panel::-webkit-scrollbar-track { background: var(--dark-bg); }
        #controls-panel::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        #controls-panel::-webkit-scrollbar-thumb:hover { background: var(--light-bg); }
        
        #constraints-container {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; padding-top: 1rem;
        }
        #constraints-container > div {
            display: flex; gap: 0.5rem; align-items: center;
        }
        #constraints-container label {
            color: var(--text-medium); font-weight: 400; font-size: 0.9rem;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group">
                 <div style="display: flex; align-items: center; gap: 0.5rem;">
                     <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     <div class="help-tooltip-container">
                        <span class="help-icon">?</span>
                        <div class="tooltip-content">
                            <h4>Misfit Le Bail Fitting</h4>
                            <p>Refine lattice parameters for two phases simultaneously, with the option to constrain parameters between them. This is useful for analyzing misfit compounds or composites.</p>
                            <p>The profile used is GSAS Profile 4. The background is determined using a rolling ball algorithm and fixed during the main refinement.</p>
                            <hr>
                             <p>Click and drag the plot, use the mouse wheel to zoom (zoom is axis-sensitive), or right-click to reset view.</p>
                        </div>
                    </div>
                </div>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml,.brml,.ras,.esd,.std,.udf,.gsa">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
                <div id="tab-panel-sample" class="tab-content-panel active">
                    <div class="control-group">
                        <h2>Phase 1 Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice-p1" class="control-label">System</label>
                            <select id="bravais-lattice-p1" class="control-select">
                                <option value="cubic_F">Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="hexagonal_R">Trigonal (R, Hex. axes)</option>
                                <option value="rhombohedral_P">Rhombohedral (Rhom. axes)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C" selected>Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
                        <div id="lattice-parameters-container-p1"></div>
                    </div>

                    <div class="control-group">
                        <h2>Phase 2 Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice-p2" class="control-label">System</label>
                            <select id="bravais-lattice-p2" class="control-select">
                                <option value="cubic_F">Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="hexagonal_R">Trigonal (R, Hex. axes)</option>
                                <option value="rhombohedral_P">Rhombohedral (Rhom. axes)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C" selected>Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
                        <div id="lattice-parameters-container-p2"></div>
                    </div>

                    <div class="control-group">
                        <h2>Lattice Constraints</h2>
                        <div id="constraints-container"></div>
                    </div>

                    <div class="control-group">
                        <h2>Instrumental Parameters</h2>
                                        <div class="form-row">
                            <label for="wavelength" class="control-label">Radiation (Å)</label>
                            <div class="flex" style="gap: 0.5rem; align-items: center;">
                                <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01">
                            </div>
                        </div>
                       
                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" checked>
                        </div>
        
                    </div>
                </div>

                <div id="tab-panel-background" class="tab-content-panel">
                    <div class="control-group">
                        <h2>Background (Rolling Ball)</h2>
                        
                        <div class="slider-group">
                             <label class="control-label">Ball Radius (pts)</label>
                             <div class="slider-value-track">
                                <input type="range" id="ball-radius-slider" class="custom-slider" min="1" max="150" value="30" step="1">
                                <span id="ball-radius-value" class="slider-value-display">30</span>
                             </div>
                        </div>

                         <div class="slider-group">
                             <label class="control-label">Smoothing (pts)</label>
                             <div class="slider-value-track">
                                <input type="range" id="smoothing-width-slider" class="custom-slider" min="1" max="50" value="5" step="1">
                                <span id="smoothing-width-value" class="slider-value-display">5</span>
                             </div>
                        </div>
                    </div>
                </div>

                <div id="tab-panel-profile" class="tab-content-panel">
                     <div class="control-group">
                        <div id="profile-controls-container">
                            <h3 class="profile-section-header">Gaussian Broadening</h3>
                            <label class="control-label">GU</label>
                            <input type="number" id="param-gu" value="2.0" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-gu" class="fit-checkbox">
                            <label class="control-label">GV</label>
                            <input type="number" id="param-gv" value="-1.0" step="0.1" class="control-input">
                            <input type="checkbox" id="fit-gv" class="fit-checkbox">
                            <label class="control-label">GW</label>
                            <input type="number" id="param-gw" value="1.0" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-gw" class="fit-checkbox">
                             <label class="control-label">GP</label>
                            <input type="number" id="param-gp" value="0.0" step="0.1" class="control-input">
                            <input type="checkbox" id="fit-gp" class="fit-checkbox">

                            <h3 class="profile-section-header">Lorentzian Broadening</h3>
                            <label class="control-label">LX</label>
                            <input type="number" id="param-lx" value="12.8" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-lx" class="fit-checkbox">

                             <h3 class="profile-section-header">Peak Shape & Position</h3>
                             <label class="control-label">eta (Mixing)</label>
                            <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
                            <input type="checkbox" id="fit-eta" class="fit-checkbox">
                             <label class="control-label">shft (Displ.)</label>
                            <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
                            <input type="checkbox" id="fit-shft" class="fit-checkbox">
                             <label class="control-label">trns (Transp.)</label>
                            <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
                            <input type="checkbox" id="fit-trns" class="fit-checkbox">
                        </div>
                    </div>
                </div>
            </div>

            <div class="bottom-actions"> 
                 <div class="control-group">
                     <h2>Refinement</h2>
                     <div class="form-row">
                        <label for="algorithm-select" class="control-label">Method</label>
                        <select id="algorithm-select" class="control-select">
                           <option value="lm">Levenberg-Marquardt</option>
                           <option value="sa" selected>Simulated Annealing</option>
                        </select>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="2" max="200" value="120" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">120</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-top: 1rem;">
                        <div id="progress-bar" style="background-color: var(--primary-accent); height: 100%; width: 0%; border-radius: 9999px;"></div>
                     </div>
                     <div class="results-grid" style="margin-top: 1rem;">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1.5rem;">
                    <button id="fit-button" class="btn btn-primary" disabled>Load Data to Start Fit</button>
                    <div style="display: flex; gap: 0.75rem;">
                        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
                        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin.</p>
            </div>

            <div id="results-container" class="hidden">
                <canvas id="main-chart"></canvas>
            </div>

            <div style="position: absolute; bottom: 0.5rem; right: 1rem; font-size: 0.75rem; color: #9ca3af;">
                NitaD, Univ Paris-Saclay, 19 Sept 2025
            </div>
        </div>
    </div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- UI Elements ---
        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLatticeP1: document.getElementById('bravais-lattice-p1'),
            latticeParamsContainerP1: document.getElementById('lattice-parameters-container-p1'),
            bravaisLatticeP2: document.getElementById('bravais-lattice-p2'),
            latticeParamsContainerP2: document.getElementById('lattice-parameters-container-p2'),
            constraintsContainer: document.getElementById('constraints-container'),
            wavelength: document.getElementById('wavelength'),
            zeroShift: document.getElementById('zero-shift'), fitZeroShift: document.getElementById('fit-zero-shift'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'), iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'), tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'), tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'), progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
            ballRadiusSlider: document.getElementById('ball-radius-slider'),
            ballRadiusValue: document.getElementById('ball-radius-value'),
            smoothingWidthSlider: document.getElementById('smoothing-width-slider'),
            smoothingWidthValue: document.getElementById('smoothing-width-value'),
        };

        // --- Global State ---
        let fullExperimentalData = { tth: [], intensity: [] };
        let fitResults = null;
        let mainChart;
        let isFitting = false;
        let lastGeneratedHklList = []; 
        let lastRawDifference = [];
        let calculatedBackground = []; 
        
        // --- Core Logic ---
        function getSystemAndCentering(phaseIndex) {
            const selectEl = (phaseIndex === 1) ? controls.bravaisLatticeP1 : controls.bravaisLatticeP2;
            const value = selectEl.value;
            const [system, centering] = value.split('_');
            return { system, centering };
        }

        function updateLatticeParamUI(phaseIndex) {
            const { system } = getSystemAndCentering(phaseIndex);
            const container = (phaseIndex === 1) ? controls.latticeParamsContainerP1 : controls.latticeParamsContainerP2;
            container.innerHTML = '';

            const createInput = (name, label, value, step, isAngle = false) => {
                const id_base = `lattice-param-${name}-p${phaseIndex}`;
                const unit = isAngle ? '°' : 'Å';
                const minAttribute = isAngle ? '' : 'min="0.001"';
                
                const row = document.createElement('div');
                row.className = 'parameter-grid-3col';
                row.innerHTML = `
                    <label for="${id_base}" class="control-label">${label} (${unit})</label>
                    <input type="number" id="${id_base}" value="${value}" step="${step}" class="control-input" ${minAttribute}>
                    <input type="checkbox" id="fit-lattice-${name}-p${phaseIndex}" class="fit-checkbox" title="Fit this parameter" checked>
                `;
                container.appendChild(row);
            };

            const params = {
                cubic: [{ name: 'a', label: 'a', value: 4.08, step: 0.001 }],
                tetragonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 5.0, step: 0.001 }],
                orthorhombic: [{ name: 'a', label: 'a', value: 4.8, step: 0.001 }, { name: 'b', label: 'b', value: 4.565, step: 0.001 }, { name: 'c', label: 'c', value: 2.8, step: 0.001 }],
                hexagonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }],
                rhombohedral: [{ name: 'a', label: 'a', value: 5.0, step: 0.001 }, { name: 'alpha', label: 'α', value: 60.0, step: 0.01, isAngle: true }],
                monoclinic: [{ name: 'a', label: 'a', value: 4.83, step: 0.001 }, { name: 'b', label: 'b', value: 2.82, step: 0.001 }, { name: 'c', label: 'c', value: 10.84, step: 0.001 }, { name: 'beta', label: 'β', value: 98.1, step: 0.01, isAngle: true }]
            };
            
            if(params[system]) {
                params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
            }
        }

        function updateConstraintsUI() {
            const container = controls.constraintsContainer;
            container.innerHTML = '';
            const paramNames = ['a', 'b', 'c', 'alpha', 'beta', 'gamma'];
            paramNames.forEach(p => {
                const label = p.length === 1 ? p : (p === 'alpha' ? 'α' : (p === 'beta' ? 'β' : 'γ'));
                container.innerHTML += `
                    <div>
                        <input type="checkbox" id="constraint-${p}" class="constraint-checkbox">
                        <label for="constraint-${p}">${label}</label>
                    </div>
                `;
            });
            // Default constraints for Ca-cobaltate case
            document.getElementById('constraint-a').checked = true;
            document.getElementById('constraint-c').checked = true;
        }

        const systemParameters = {
            cubic: ['a'],
            tetragonal: ['a', 'c'],
            orthorhombic: ['a', 'b', 'c'],
            hexagonal: ['a', 'c'],
            rhombohedral: ['a', 'alpha'],
            monoclinic: ['a', 'b', 'c', 'beta']
        };

        function updateAvailableConstraints() {
            const { system: systemP1 } = getSystemAndCentering(1);
            const { system: systemP2 } = getSystemAndCentering(2);

            const paramsP1 = systemParameters[systemP1] || [];
            const paramsP2 = systemParameters[systemP2] || [];

            const commonParams = paramsP1.filter(p => paramsP2.includes(p));
            const allPossibleParams = ['a', 'b', 'c', 'alpha', 'beta', 'gamma'];
            allPossibleParams.forEach(param => {
                const checkbox = document.getElementById(`constraint-${param}`);
                if (checkbox) {
                    const isCommon = commonParams.includes(param);
                    checkbox.disabled = !isCommon;
                    if (!isCommon) checkbox.checked = false;
                }
            });
            updateConstraintStates();
        }

        // --- All-in-one File Parsing Logic ---

/**
 * Detects file type based on name and content, then calls the appropriate parser.
 * This is the main function to call after a file is read.
 * @param {string} fileName - The name of the file.
 * @param {string} fileContent - The text content of the file.
 * @returns {object} An object containing {tth, intensity, wavelength?}.
 */
const detectAndParseFile = (fileName, fileContent) => {
    const name = fileName.toLowerCase();
    const lines = fileContent.trim().split(/\r?\n/);
    const firstLine = lines.length > 0 ? lines[0].trim() : '';

    if (name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) {
        return parseUxdFile(fileContent);
    }
    if (name.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) {
        return parseXrdmlFile(fileContent);
    }
    if (name.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) {
        return parseBrukerBrmlFile(fileContent);
    }
    if (name.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) {
        return parseRigakuRasFile(fileContent);
    }
    if (name.endsWith('.udf')) {
        return parsePhilipsUdfFile(fileContent);
    }
    // Check for GSAS file by looking for 'BANK' on the second line
    if (lines.length > 2 && lines[1].toUpperCase().includes('BANK')) {
         return parseGsasEsdFile(fileContent);
    }
    // Fallback to generic 2-column parser
    return parseDataFile(fileContent);
};

// --- Individual Parsers ---

/** Parses generic 2-column (2-theta, intensity) data files. */
const parseDataFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    const tth = [], intensity = [];
    lines.forEach(line => {
        if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return;
        const parts = line.trim().split(/[\s,;]+/);
        if (parts.length >= 2) {
            const x = parseFloat(parts[0]);
            const y = parseFloat(parts[1]);
            if (!isNaN(x) && !isNaN(y)) {
                tth.push(x);
                intensity.push(y);
            }
        }
    });
    return { tth, intensity };
};

/** Parses Panalytical XRDML format. */
const parseXrdmlFile = (xmlString) => {
     const parser = new DOMParser();
     const xmlDoc = parser.parseFromString(xmlString, "application/xml");
     if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); }

     let wavelength = null;
     const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
     if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent);

     const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
     if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file.");
     const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

     const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
     if (!positionsNode) throw new Error("Could not find <positions> in XRDML file.");
     const startPosNode = positionsNode.querySelector("startPosition");
     const endPosNode = positionsNode.querySelector("endPosition");

     if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML.");
     const startPos = parseFloat(startPosNode.textContent);
     const endPos = parseFloat(endPosNode.textContent);
     const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1));

     return { tth, intensity, wavelength };
};

/** Parses Bruker BRML format. */
const parseBrukerBrmlFile = (xmlString) => {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "application/xml");
    if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); }

    let wavelength = null;
    const wlNode = xmlDoc.querySelector('usedWavelength');
    if (wlNode) {
        const kAlpha1 = wlNode.getAttribute('kAlpha1');
        if (kAlpha1) wavelength = parseFloat(kAlpha1);
    }
    
    const intensityNode = xmlDoc.querySelector("dataPoints > counts");
    if (!intensityNode) throw new Error("No <counts> data found in BRML file.");
    const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

    const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]');
    const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]');
    if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file.");

    const startPos = parseFloat(startPosNode.textContent);
    const stepSize = parseFloat(stepSizeNode.textContent);
    
    const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize);

    return { tth, intensity, wavelength };
};

/** Parses Rigaku RAS format. */
const parseRigakuRasFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    const tth = [], intensity = [];
    let inDataSection = false;
    let wavelength = null;

    for (const line of lines) {
        const upperLine = line.toUpperCase();
        if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) {
            const parts = line.trim().split(/\s+/);
            if (parts.length > 1) {
                const wl = parseFloat(parts[1]);
                if (!isNaN(wl)) wavelength = wl;
            }
        }
        if (upperLine.startsWith('*RAS_INT_START')) {
            inDataSection = true;
            continue;
        }
        if (upperLine.startsWith('*RAS_INT_END')) {
            break;
        }
        if (inDataSection) {
            const parts = line.trim().split(/[\s,]+/);
            if (parts.length >= 2) {
                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);
                if (!isNaN(x) && !isNaN(y)) {
                    tth.push(x);
                    intensity.push(y);
                }
            }
        }
    }
    if (tth.length === 0) throw new Error("No data found in RAS file data section.");
    return { tth, intensity, wavelength };
};

/** Parses GSAS ESD format. */
const parseGsasEsdFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;

    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }

        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1;
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) {
        throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    }
    if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) {
        dataStartIndex++;
    }
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) {
        throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines.");
    }
    
    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        const parts = lines[i].trim().split(/\s+/);
        for (let j = 1; j < parts.length; j += 2) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }

    if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};

/** Parses UXD format. */
const parseUxdFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    const intensity = [];
    let startTth, stepSize, wavelength;
    let inDataSection = false;

    for (const line of lines) {
        const trimmedLine = line.trim();
        if (inDataSection) {
            const parts = trimmedLine.split(/\s+/);
            parts.forEach(part => {
                const val = parseFloat(part);
                if (!isNaN(val)) intensity.push(val);
            });
        } else {
            if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7));
            else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10));
            else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5));
            else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true;
        }
    }

    if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file.");
    if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};

/** Parses Philips UDF format. */
const parsePhilipsUdfFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    const tth = [], intensity = [];
    let inDataSection = false;
    let wavelength = null;

    for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine.toUpperCase().startsWith('LAMBDA')) {
            const parts = trimmedLine.split('=');
            if (parts.length > 1) wavelength = parseFloat(parts[1]);
        }
        if (trimmedLine.toUpperCase() === '[DATA]') {
            inDataSection = true;
            continue;
        }
        if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') {
            inDataSection = false;
        }
        if (inDataSection) {
            const parts = trimmedLine.split(/,/).map(p => p.trim());
            if(parts.length >= 2) {
                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);
                if (!isNaN(x) && !isNaN(y)) {
                    tth.push(x);
                    intensity.push(y);
                }
            }
        }
    }
    if (tth.length === 0) throw new Error("No [Data] section found in UDF file.");
    return { tth, intensity, wavelength };
};


        function getWorkingData(subtractBackground = false) {
            if (fullExperimentalData.tth.length === 0) return { tth: [], intensity: [] };
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);
            const startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;

            const tth = fullExperimentalData.tth.slice(startIndex, endIndex);
            let intensity = fullExperimentalData.intensity.slice(startIndex, endIndex);

            if (subtractBackground && calculatedBackground.length === fullExperimentalData.intensity.length) {
                const backgroundSlice = calculatedBackground.slice(startIndex, endIndex);
                intensity = intensity.map((y, i) => Math.max(0, y - backgroundSlice[i]));
            }
            return { tth, intensity };
        }

        function matrixInverse(A) {
            const n = A.length;
            if (n === 0 || A.length !== A[0]?.length) return null;
            const I = Array.from({ length: n }, (_, i) => Array.from({ length: n }, (_, j) => (i === j ? 1 : 0)));
            const C = A.map((row, i) => [...row, ...I[i]]);
            for (let i = 0; i < n; i++) {
                let pivot = i;
                for (let j = i + 1; j < n; j++) { if (Math.abs(C[j][i]) > Math.abs(C[pivot][i])) pivot = j; }
                [C[i], C[pivot]] = [C[pivot], C[i]];
                const div = C[i][i];
                if (Math.abs(div) < 1e-12) return null; // Singular matrix
                for (let j = i; j < 2 * n; j++) C[i][j] /= div;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const mult = C[j][i];
                        for (let k = i; k < 2 * n; k++) C[j][k] -= mult * C[i][k];
                    }
                }
            }
            return C.map(row => row.slice(n));
        }

        function findExperimentalPeakDetails(targetTth, experimentalData, wavelength, searchWindow = 0.5) {
            if (!experimentalData || experimentalData.tth.length === 0) return { tth_exp: null, d_exp: null };
            const minTth = targetTth - searchWindow;
            const maxTth = targetTth + searchWindow;
            let maxIntensity = -Infinity;
            let tth_exp = null;
            for (let i = 0; i < experimentalData.tth.length; i++) {
                const tth = experimentalData.tth[i];
                if (tth >= minTth && tth <= maxTth) {
                    if (experimentalData.intensity[i] > maxIntensity) {
                        maxIntensity = experimentalData.intensity[i];
                        tth_exp = tth;
                    }
                }
            }
            if (tth_exp !== null) {
                const theta_rad = tth_exp * (Math.PI / 180) / 2;
                const d_exp = wavelength / (2 * Math.sin(theta_rad));
                return { tth_exp: tth_exp, d_exp: d_exp };
            }
            return { tth_exp: null, d_exp: null };
        }

        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }


        function rollingBallBackground(y, radius, smoothingWidth) {
            const n = y.length;
            if (n === 0 || radius <= 0) return new Array(n).fill(0);

            let smoothed_y = y;
            if (smoothingWidth > 1) {
                smoothed_y = new Array(n);
                const halfWidth = Math.floor(smoothingWidth / 2);
                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - halfWidth);
                    const end = Math.min(n, i + halfWidth + 1);
                    let sum = 0;
                    for (let j = start; j < end; j++) sum += y[j];
                    smoothed_y[i] = sum / (end - start);
                }
            }
            const eroded = new Array(n);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - radius), end = Math.min(n, i + radius + 1);
                let min = Infinity;
                for (let j = start; j < end; j++) if (smoothed_y[j] < min) min = smoothed_y[j];
                eroded[i] = min;
            }
            const background = new Array(n);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - radius), end = Math.min(n, i + radius + 1);
                let max = -Infinity;
                for (let j = start; j < end; j++) if (eroded[j] > max) max = eroded[j];
                background[i] = max;
            }
            return background;
        }

        function updateAndApplyBackground() {
            if (fullExperimentalData.intensity.length === 0) return;
            const radius = parseInt(controls.ballRadiusSlider.value, 10);
            const smoothing = parseInt(controls.smoothingWidthSlider.value, 10);
            
            calculatedBackground = rollingBallBackground(fullExperimentalData.intensity, radius, smoothing);

            if (mainChart) {
                const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background');
                if (backgroundDataset) {
                    backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] }));
                }
                updatePreviewPattern();
            }
        }
        

        function generateTextReportContent(fitResults, controls) {
            const reportLines = [];
            const now = new Date();
            const { params: finalParams, fitFlags, algorithm, stats } = fitResults;
            let esdWarning = null;

            // --- Calculate ESDs if this was an LM fit ---
            let esds = {};
            if (algorithm === 'lm' && fitResults.JtJ) {
                const workingDataForStats = getWorkingData(true);
                const N = workingDataForStats.intensity.length;
                const P = fitResults.paramMapping.length;
                if (N > P && fitResults.ss_res !== undefined) {
                    const reduced_chi_sq = fitResults.ss_res / (N - P);
                    const cov_matrix = matrixInverse(fitResults.JtJ);
                    if (cov_matrix) {
                        fitResults.paramMapping.forEach((p, i) => {
                            if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                esds[p.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i]));
                            }
                        });
                    } else {
                        esdWarning = "--> ESD calculation failed: matrix is singular (check for correlated parameters).";
                    }
                }
            }

            const formatParamLine = (name, value, isFitted, esdKey) => {
                let valStr = (typeof value === 'number') ? value.toExponential(6).padStart(15) : String(value).padStart(15);
                const fitStr = (isFitted === undefined) ? '' : (typeof isFitted === 'string' ? isFitted.padStart(8) : (isFitted ? 'Yes'.padStart(8) : 'No'.padStart(8)));
                let esdStr = '-'.padStart(15);
                if (algorithm === 'lm' && isFitted) {
                   esdStr = (esds[esdKey] !== undefined) ? `(${esds[esdKey].toExponential(2)})`.padStart(15) : '(calc. failed)'.padStart(15);
                }
                return `${name.padEnd(14)}${valStr} ${fitStr}   ${esdStr}`;
            };
            
            reportLines.push('======================================================================');
            reportLines.push('                   Misfit Le Bail Refinement Report');
            reportLines.push('======================================================================');
            reportLines.push(`Report Generated: ${now.toLocaleString()}`);
            reportLines.push(`Data File: ${controls.fileName.textContent}`);
            reportLines.push('');
            reportLines.push('--- Refinement Statistics ---');
            reportLines.push(`Rp (%):      ${stats.r_p.toFixed(4)}`);
            reportLines.push(`Rwp (%):     ${stats.rwp.toFixed(4)}`);
            reportLines.push(`χ² (GOF):    ${stats.chi2.toFixed(4)}`);
            reportLines.push(`Algorithm:   ${algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`);
            if (esdWarning) reportLines.push(esdWarning);
            reportLines.push('');

            const constraints = getConstraints();
            const header = 'Parameter'.padEnd(14) + 'Value'.padStart(15) + ' ' + 'Fitted'.padStart(8) + '   ' + 'Std. Error (ESD)'.padStart(15);

            // --- Phase 1 ---
            reportLines.push('--- Phase 1 Parameters ---');
            reportLines.push(header);
            reportLines.push('-'.repeat(header.length + 2));
            const p1_system_text = controls.bravaisLatticeP1.options[controls.bravaisLatticeP1.selectedIndex].text;
            reportLines.push(`System: ${p1_system_text}`);
            ['a','b','c','alpha','beta','gamma'].forEach(p => {
                if(finalParams.phase1[p]) reportLines.push(formatParamLine(`${p}`, finalParams.phase1[p], fitFlags.phase1[p], constraints[`constrain_${p}`] ? `${p}_shared` : `${p}1`));
            });
            reportLines.push('');
            
            // --- Phase 2 ---
            reportLines.push('--- Phase 2 Parameters ---');
            reportLines.push(header);
            reportLines.push('-'.repeat(header.length + 2));
            const p2_system_text = controls.bravaisLatticeP2.options[controls.bravaisLatticeP2.selectedIndex].text;
            reportLines.push(`System: ${p2_system_text}`);
             ['a','b','c','alpha','beta','gamma'].forEach(p => {
                if(finalParams.phase2[p]) {
                    const isConstrained = constraints[`constrain_${p}`];
                    reportLines.push(formatParamLine(`${p}`, finalParams.phase2[p], isConstrained ? '(constr.)' : fitFlags.phase2[p], isConstrained ? `${p}_shared` : `${p}2`));
                }
            });
            reportLines.push('');
            
            // --- Shared Parameters ---
            reportLines.push('--- Shared & Profile Parameters ---');
            reportLines.push(header);
            reportLines.push('-'.repeat(header.length + 2));
            reportLines.push(`Radiation (Å): ${finalParams.lambda}`);
            ['zeroShift','GU','GV','GW','GP','LX','eta','shft','trns'].forEach(p => {
                 reportLines.push(formatParamLine(p, finalParams[p], fitFlags[p], p));
            });
            reportLines.push('');

            const maxTth = Math.max(...fullExperimentalData.tth);
            const hklList1 = generateHKL(maxTth, finalParams.phase1, finalParams.phase1.system, finalParams.phase1.centering, 'P1');
            const hklList2 = generateHKL(maxTth, finalParams.phase2, finalParams.phase2.system, finalParams.phase2.centering, 'P2');
            const combinedHklList = hklList1.concat(hklList2).sort((a,b) => a.tth - b.tth);

            reportLines.push('--- Calculated vs. Experimental Reflections ---');
            reportLines.push(['Phase'.padEnd(6), 'h,k,l'.padEnd(12), 'd_calc (Å)'.padStart(12), 'd_exp (Å)'.padStart(12), '2th_corr (°)' .padStart(15), '2th_exp (°)' .padStart(15)].join('  '));
            reportLines.push('-'.repeat(80));

            combinedHklList.forEach(hkl => {
                const peakShift = calculatePeakShift(hkl.tth, finalParams);
                const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                const { tth_exp, d_exp } = findExperimentalPeakDetails(tthCorr, fullExperimentalData, finalParams.lambda);
                const line = [
                    hkl.phase.padEnd(6), hkl.hkl_list[0].padEnd(12), hkl.d.toFixed(5).padStart(12),
                    (d_exp ? d_exp.toFixed(5) : 'N/A').padStart(12), tthCorr.toFixed(4).padStart(15),
                    (tth_exp ? tth_exp.toFixed(4) : 'N/A').padStart(15)
                ].join('  ');
                reportLines.push(line);
            });
            reportLines.push('');

            // --- Add the intensity data table ---
            reportLines.push('--- Intensity Data ---');
            reportLines.push(['2theta'.padStart(12), 'I_obs'.padStart(15), 'I_calc'.padStart(15), 'Difference'.padStart(15)].join(' '));
            reportLines.push('-'.repeat(60));
            
            const netPattern = calculateNetPattern(fullExperimentalData.tth, combinedHklList, finalParams);
            const scaledNetPattern = netPattern.map(y => y * stats.scaleFactor);
            const totalCalcPattern = scaledNetPattern.map((y,i) => y + calculatedBackground[i]);

            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const tth = fullExperimentalData.tth[i];
                const i_obs = fullExperimentalData.intensity[i];
                const i_calc = totalCalcPattern[i];
                const diff = i_obs - i_calc;
                reportLines.push([
                    tth.toFixed(4).padStart(12),
                    i_obs.toFixed(3).padStart(15),
                    i_calc.toFixed(3).padStart(15),
                    diff.toFixed(3).padStart(15)
                ].join(' '));
            }
            
            return reportLines.join('\n');
        }


        function generateHKL(maxTth, phaseParams, system, centering, phaseTag) {
            const { a, b, c, alpha, beta } = phaseParams;
            const lambda = parseFloat(controls.wavelength.value);
            if (!a || !lambda || a <= 0) return [];

            const reflections = new Map();
            const maxLatticeParam = Math.max(a || 0, b || 0, c || 0);
            if (maxLatticeParam === 0) return [];
            const maxIndex = Math.ceil(2 * maxLatticeParam / lambda * Math.sin(maxTth / 2 * Math.PI / 180)) + 2;
            
            const deg2rad = Math.PI / 180;
            
            for (let h = -maxIndex; h <= maxIndex; h++) {
            for (let k = -maxIndex; k <= maxIndex; k++) {
            for (let l = 0; l <= maxIndex; l++) {
                if (h === 0 && k === 0 && l === 0) continue;

                let allowed = false;
                switch(centering) {
                    case 'P': allowed = true; break;
                    case 'I': allowed = (h + k + l) % 2 === 0; break;
                    case 'F': allowed = (h % 2 === k % 2) && (k % 2 === l % 2); break;
                    case 'C': allowed = (h + k) % 2 === 0; break;
                    case 'R': allowed = (system === 'hexagonal') ? (-h + k + l) % 3 === 0 : true; break;
                    default: allowed = true;
                }
                if (!allowed) continue;

                let inv_d_sq = 0;
                try {
                    switch(system) {
                        case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                        case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                        case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                        case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                        case 'monoclinic': 
                            const sin_b_sq = Math.sin((beta || 90) * deg2rad)**2;
                            if (sin_b_sq < 1e-9) continue;
                            inv_d_sq = (1/sin_b_sq) * ( (h*h)/(a*a) + (k*k*sin_b_sq)/(b*b) + (l*l)/(c*c) - (2*h*l*Math.cos((beta || 90)*deg2rad))/(a*c) );
                            break;
                        case 'rhombohedral':
                            const cos_a = Math.cos((alpha || 90) * deg2rad);
                            const denominator = a*a * (1 - 3*cos_a**2 + 2*cos_a**3);
                            if(Math.abs(denominator) < 1e-9) continue;
                            inv_d_sq = ((h*h + k*k + l*l) * Math.sin((alpha || 90)*deg2rad)**2 + 2 * (h*k + k*l + l*h) * (cos_a**2 - cos_a)) / denominator;
                            break;
                    }
                } catch (e) { continue; }

                if (inv_d_sq <= 0 || !isFinite(inv_d_sq)) continue;
                
                const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                if (sinThetaSq <= 1) {
                    const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                    if (tth > maxTth * 1.05) continue;
                    const d = 1 / Math.sqrt(inv_d_sq);
                    const key = `${phaseTag}-${Math.round(tth * 1000)}`;
                    if (!reflections.has(key)) {
                        reflections.set(key, { tth: tth, d: d, hkl_list: [`(${h},${k},${l})`], intensity: 0, phase: phaseTag });
                    } else {
                        reflections.get(key).hkl_list.push(`(${h},${k},${l})`);
                    }
                }
            }}}
            return Array.from(reflections.values()).sort((a, b) => a.tth - b.tth);
        }

        function calculatePeakShift(tth, params) {
            const thetaRad = tth * (Math.PI / 180) / 2;
            const cosTheta = Math.cos(thetaRad);
            return -(params.shft / 1000) * cosTheta * (180 / Math.PI) + params.trns * Math.sin(2 * thetaRad);
        }

        function calculateProfileWidths(tth, params) {
            const thetaRad = Math.min(tth * (Math.PI / 180) / 2, 89.999 * Math.PI / 180);
            const tanTheta = Math.tan(thetaRad);
            const cosTheta = Math.cos(thetaRad);
            const gamma_G_sq = (params.GU/100)*tanTheta*tanTheta + (params.GV/100)*tanTheta + (params.GW/100) + (params.GP/100)/(cosTheta*cosTheta);
            return { gamma_G: Math.sqrt(Math.max(1e-6, gamma_G_sq)), gamma_L: (params.LX / 100) / cosTheta };
        }

        function pseudoVoigt(x, x0, gamma_G, gamma_L, eta) {
            if (gamma_G <= 1e-6 && gamma_L <= 1e-6) return 0.0;
            const fwhm_g_to_sigma = 1 / (2 * Math.sqrt(2 * Math.log(2)));
            const normalizedGaussian = Math.exp(-0.5 * ((x - x0) / (gamma_G * fwhm_g_to_sigma)) ** 2);
            const hwhm_l = gamma_L / 2.0;
            const normalizedLorentzian = (hwhm_l**2) / ((x - x0)**2 + hwhm_l**2);
            if (gamma_L < 1e-6) return normalizedGaussian;
            if (gamma_G < 1e-6) return normalizedLorentzian;
            return eta * normalizedLorentzian + (1 - eta) * normalizedGaussian;
        }
        
        function calculateNetPattern(tthAxis, hklList, params) {
            const pattern = new Float32Array(tthAxis.length).fill(0);
            hklList.forEach(peak => {
                const basePos = peak.tth + params.zeroShift;
                const peakPos = basePos + calculatePeakShift(basePos, params);
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos, params);
                for (let i = 0; i < tthAxis.length; i++) {
                    if (Math.abs(tthAxis[i] - peakPos) < 5 * (gamma_G + gamma_L)) {
                       pattern[i] += peak.intensity * pseudoVoigt(tthAxis[i], peakPos, gamma_G, gamma_L, params.eta);
                    }
                }
            });
            return pattern;
        }

        function leBailIntensityExtraction(exp_net, hklList, params) {
            hklList.forEach(p => p.intensity = 0);
            for(let i = 0; i < exp_net.tth.length; i++) {
                let totalProfileAtPoint = 0;
                const contributingPeaks = [];
                hklList.forEach((peak, peakIdx) => {
                    const basePos = peak.tth + params.zeroShift;
                    const peakPos = basePos + calculatePeakShift(basePos, params);
                    const { gamma_G, gamma_L } = calculateProfileWidths(basePos, params);
                    if(Math.abs(exp_net.tth[i] - peakPos) < 5 * (gamma_G + gamma_L)) {
                        const profileVal = pseudoVoigt(exp_net.tth[i], peakPos, gamma_G, gamma_L, params.eta);
                        totalProfileAtPoint += profileVal;
                        contributingPeaks.push({idx: peakIdx, val: profileVal});
                    }
                });
                if(totalProfileAtPoint > 1e-9) {
                    const obsIntensityNet = exp_net.intensity[i]; // Already background-subtracted
                    contributingPeaks.forEach(p => {
                        hklList[p.idx].intensity += obsIntensityNet * (p.val / totalProfileAtPoint);
                    });
                }
            }
            const maxIntensity = Math.max(...hklList.map(p => p.intensity));
            if (maxIntensity > 0) hklList.forEach(p => p.intensity = p.intensity / maxIntensity * 1000);
        }

        function calculateStatistics(totalWorkingData, netCalcPattern, backgroundSlice, fitFlags) {
            const y_obs_total = totalWorkingData.intensity;
            const y_calc_net = netCalcPattern;
            const y_bkg = backgroundSlice;
            const N = y_obs_total.length;
            const P = getParameterMapping(fitFlags, getConstraints()).paramMapping.length;

            const y_obs_net = y_obs_total.map((y, i) => y - y_bkg[i]);
            let sum_obs_net_calc_net = 0;
            let sum_calc_net_sq = 0;
            for (let i = 0; i < N; i++) {
                sum_obs_net_calc_net += y_obs_net[i] * y_calc_net[i];
                sum_calc_net_sq += y_calc_net[i] * y_calc_net[i];
            }
            const scaleFactor = sum_calc_net_sq > 0 ? sum_obs_net_calc_net / sum_calc_net_sq : 1.0;
            const y_calc_total = y_calc_net.map((y, i) => (scaleFactor * y) + y_bkg[i]);

            const weights = y_obs_total.map(y => 1 / Math.max(y, 1));
            let sum_w_res_sq = 0, sum_w_obs_sq = 0, sum_abs_res = 0, sum_abs_obs = 0;

            for (let i = 0; i < N; i++) {
                const res = y_obs_total[i] - y_calc_total[i];
                sum_w_res_sq += weights[i] * res * res;
                sum_w_obs_sq += weights[i] * y_obs_total[i] * y_obs_total[i];
                sum_abs_res += Math.abs(res);
                sum_abs_obs += Math.abs(y_obs_total[i]);
            }

            const r_p = sum_abs_obs > 0 ? 100 * (sum_abs_res / sum_abs_obs) : 0;
            const rwp = sum_w_obs_sq > 0 ? 100 * Math.sqrt(sum_w_res_sq / sum_w_obs_sq) : 0;
            const chi2 = (N - P) > 0 ? sum_w_res_sq / (N - P) : Infinity;
            
            return { r_p, rwp, chi2, scaleFactor };
        }
        
        function getAllParams() {
            const getPhaseParams = (pIdx) => ({
                system: getSystemAndCentering(pIdx).system,
                centering: getSystemAndCentering(pIdx).centering,
                a: parseFloat(document.getElementById(`lattice-param-a-p${pIdx}`)?.value),
                b: parseFloat(document.getElementById(`lattice-param-b-p${pIdx}`)?.value),
                c: parseFloat(document.getElementById(`lattice-param-c-p${pIdx}`)?.value),
                alpha: parseFloat(document.getElementById(`lattice-param-alpha-p${pIdx}`)?.value),
                beta: parseFloat(document.getElementById(`lattice-param-beta-p${pIdx}`)?.value),
                gamma: parseFloat(document.getElementById(`lattice-param-gamma-p${pIdx}`)?.value),
            });
            return {
                phase1: getPhaseParams(1), phase2: getPhaseParams(2),
                lambda: parseFloat(controls.wavelength.value),
                zeroShift: parseFloat(controls.zeroShift.value), GU: parseFloat(controls.paramGU.value),
                GV: parseFloat(controls.paramGV.value), GW: parseFloat(controls.paramGW.value), GP: parseFloat(controls.paramGP.value),
                LX: parseFloat(controls.paramLX.value), eta: parseFloat(controls.paramEta.value),
                shft: parseFloat(controls.paramShft.value), trns: parseFloat(controls.paramTrns.value),
            };
        }
        
        function getFitFlags() {
            const getPhaseFlags = (pIdx) => ({
                a: document.getElementById(`fit-lattice-a-p${pIdx}`)?.checked, b: document.getElementById(`fit-lattice-b-p${pIdx}`)?.checked,
                c: document.getElementById(`fit-lattice-c-p${pIdx}`)?.checked, alpha: document.getElementById(`fit-lattice-alpha-p${pIdx}`)?.checked,
                beta: document.getElementById(`fit-lattice-beta-p${pIdx}`)?.checked, gamma: document.getElementById(`fit-lattice-gamma-p${pIdx}`)?.checked,
            });
            return {
                phase1: getPhaseFlags(1), phase2: getPhaseFlags(2),
                zeroShift: controls.fitZeroShift.checked, GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked,
                GP: controls.fitGP.checked, LX: controls.fitLX.checked, eta: controls.fitEta.checked, shft: controls.fitShft.checked,
                trns: controls.fitTrns.checked,
            };
        }

        function getConstraints() {
            const constraints = {};
            ['a', 'b', 'c', 'alpha', 'beta', 'gamma'].forEach(p => {
                const el = document.getElementById(`constraint-${p}`);
                if(el) constraints[`constrain_${p}`] = el.checked;
            });
            return constraints;
        }

        async function runLeBailFit() {
            if (isFitting) return;
            isFitting = true; fitResults = null; setUIState(true);
            await new Promise(resolve => setTimeout(resolve, 10));
            
            updateAndApplyBackground();

            let params = getAllParams();
            const fitFlags = getFitFlags();
            const constraints = getConstraints();
            Object.keys(constraints).forEach(key => {
                const p = key.replace('constrain_', '');
                if (constraints[key] && !isNaN(params.phase1[p])) params.phase2[p] = params.phase1[p];
            });

            const maxIterations = parseInt(controls.iterationsSlider.value);
            const algorithm = controls.algorithmSelect.value;
            
            // ------
            const workingData_net = getWorkingData(true);
            const workingData_total = getWorkingData(false);
            // --- -

            let results;
            const progressCallback = async (progress, currentParams) => {
                 controls.progressBar.style.width = `${progress * 100}%`;
                 await new Promise(resolve => setTimeout(resolve, 0));
            };
            
            if (algorithm === 'lm') {
                 // Pass total intensity to LM for correct weighting
                 results = await refineParametersLM(params, fitFlags, constraints, maxIterations, progressCallback, workingData_net, workingData_total.intensity);
            } else {
                 // SA is less sensitive to weighting, so this part remains the same
                 results = await refineParametersSA(params, fitFlags, constraints, maxIterations, progressCallback);
            }
            
            fitResults = results;
            const finalParams = fitResults.params;
            
            const workingData = getWorkingData(true);
            const maxTth = Math.max(...workingData.tth);
            let hklList1 = generateHKL(maxTth, finalParams.phase1, finalParams.phase1.system, finalParams.phase1.centering, 'P1');
            let hklList2 = generateHKL(maxTth, finalParams.phase2, finalParams.phase2.system, finalParams.phase2.centering, 'P2');
            let combinedHklList = hklList1.concat(hklList2).sort((a,b)=>a.tth-b.tth);
            lastGeneratedHklList = combinedHklList;
            
            leBailIntensityExtraction(workingData, combinedHklList, finalParams);
            
            const finalWorkingPattern_NET = calculateNetPattern(workingData.tth, combinedHklList, finalParams);
            
            const finalWorkingData_TOTAL = getWorkingData(false);
            const startIndex = fullExperimentalData.tth.findIndex(t => t >= finalWorkingData_TOTAL.tth[0]);
            let endIndex = fullExperimentalData.tth.findIndex(t => t > finalWorkingData_TOTAL.tth[finalWorkingData_TOTAL.tth.length - 1]);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;
            const background_slice = calculatedBackground.slice(startIndex, endIndex);

            const finalStats = calculateStatistics(finalWorkingData_TOTAL, finalWorkingPattern_NET, background_slice, fitFlags);
            fitResults.stats = finalStats;
            
            const scaledPeakPattern_full = calculateNetPattern(fullExperimentalData.tth, combinedHklList, finalParams).map(y => y * finalStats.scaleFactor);
            
            updateUI(finalParams, finalStats, scaledPeakPattern_full, calculatedBackground);
            isFitting = false; setUIState(false);
        }


        function dot(v1, v2) { let s = 0; for(let i=0; i<v1.length; i++) s += v1[i] * v2[i]; return s; }
        function add(v1, v2) { return v1.map((x, i) => x + v2[i]); }
        function subtract(v1, v2) { return v1.map((x, i) => x - v2[i]); }
        function scale(v, s) { return v.map(x => x * s); }
        function transpose(m) {
            if (!m || m.length === 0 || !Array.isArray(m[0])) return m.map(x => [x]);
            return m[0].map((_, colIndex) => m.map(row => row[colIndex]));
        }
        function multiply(A, B) {
            if (!Array.isArray(B[0])) return A.map(row => dot(row, B));
            const Bt = transpose(B);
            return A.map(rowA => Bt.map(colB => dot(rowA, colB)));
        }
        function solve(A, b) {
            const n = A.length, Ab = A.map((row, i) => [...row, b[i]]);
            for (let i = 0; i < n; i++) {
                let max = i; for (let k = i + 1; k < n; k++) { if (Math.abs(Ab[k][i]) > Math.abs(Ab[max][i])) max = k; }
                [Ab[i], Ab[max]] = [Ab[max], Ab[i]];
                if (Math.abs(Ab[i][i]) < 1e-12) continue;
                for (let k = i + 1; k < n; k++) {
                    const factor = Ab[k][i] / Ab[i][i]; if (!isFinite(factor)) continue;
                    for (let j = i; j < n + 1; j++) Ab[k][j] -= factor * Ab[i][j];
                }
            }
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) { let sum = 0; for (let j = i + 1; j < n; j++) sum += Ab[i][j] * x[j]; if (Math.abs(Ab[i][i]) > 1e-12) x[i] = (Ab[i][n] - sum) / Ab[i][i]; }
            return x;
        }

        function getParameterMapping(fitFlags, constraints) {
            const paramMapping = [];
            const latticeParamNames = ['a', 'b', 'c', 'alpha', 'beta', 'gamma'];
            latticeParamNames.forEach(pName => {
                if (constraints[`constrain_${pName}`]) {
                    if (fitFlags.phase1[pName] || fitFlags.phase2[pName]) {
                        paramMapping.push({
                            name: `${pName}_shared`,
                            get: p => p.phase1[pName],
                            set: (p, v) => { p.phase1[pName] = v; p.phase2[pName] = v; },
                            step: ['a', 'b', 'c'].includes(pName) ? 1e-3 : 1e-2
                        });
                    }
                } else {
                    if (fitFlags.phase1[pName]) paramMapping.push({ name: `${pName}1`, get: p => p.phase1[pName], set: (p, v) => p.phase1[pName] = v, step: ['a','b','c'].includes(pName) ? 1e-3: 1e-2 });
                    if (fitFlags.phase2[pName]) paramMapping.push({ name: `${pName}2`, get: p => p.phase2[pName], set: (p, v) => p.phase2[pName] = v, step: ['a','b','c'].includes(pName) ? 1e-3: 1e-2 });
                }
            });
            const sharedParamDefs = [
                { flag: fitFlags.zeroShift, name: 'zeroShift', get: p => p.zeroShift, set: (p, v) => p.zeroShift = v, step: 1e-3 },
                { flag: fitFlags.GU, name: 'GU', get: p => p.GU, set: (p, v) => p.GU = v, step: 0.1 }, { flag: fitFlags.GV, name: 'GV', get: p => p.GV, set: (p, v) => p.GV = v, step: 0.1 },
                { flag: fitFlags.GW, name: 'GW', get: p => p.GW, set: (p, v) => p.GW = Math.max(0, v), step: 0.1 }, { flag: fitFlags.GP, name: 'GP', get: p => p.GP, set: (p, v) => p.GP = v, step: 0.1 },
                { flag: fitFlags.LX, name: 'LX', get: p => p.LX, set: (p, v) => p.LX = Math.max(0, v), step: 0.2 }, { flag: fitFlags.eta, name: 'eta', get: p => p.eta, set: (p, v) => p.eta = Math.max(0, Math.min(1, v)), step: 0.05 },
                { flag: fitFlags.shft, name: 'shft', get: p => p.shft, set: (p, v) => p.shft = v, step: 0.01 }, { flag: fitFlags.trns, name: 'trns', get: p => p.trns, set: (p, v) => p.trns = v, step: 0.01 },
            ];
            sharedParamDefs.forEach(def => { if (def.flag) paramMapping.push(def); });
            return { paramMapping };
        }

        async function refineParametersSA(initialParams, fitFlags, constraints, maxIter, progressCallback) {
            const { paramMapping } = getParameterMapping(fitFlags, constraints);
            if (paramMapping.length === 0) return { params: initialParams, algorithm: 'sa', paramMapping, fitFlags, constraints };

            const workingData = getWorkingData(true);
            if (workingData.tth.length === 0) return { params: initialParams };
            const maxTth = Math.max(...workingData.tth);

            const objective = (p_vec, params_template) => {
                let tempParams = JSON.parse(JSON.stringify(params_template));
                paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));
                if (tempParams.phase1.a <= 0 || (tempParams.phase2.a && tempParams.phase2.a <= 0)) return 1e12;

                let hkl1 = generateHKL(maxTth, tempParams.phase1, tempParams.phase1.system, tempParams.phase1.centering, 'P1');
                let hkl2 = generateHKL(maxTth, tempParams.phase2, tempParams.phase2.system, tempParams.phase2.centering, 'P2');
                let combined = hkl1.concat(hkl2).sort((a,b)=>a.tth-b.tth);

                leBailIntensityExtraction(workingData, combined, tempParams);
                const netPattern = calculateNetPattern(workingData.tth, combined, tempParams);
                const diff = subtract(workingData.intensity, netPattern);
                return dot(diff, diff);
            };

            let T = 1.0, coolingRate = 0.99, maxSteps = maxIter;
            let current_x = paramMapping.map(m => m.get(initialParams));
            let current_cost = objective(current_x, initialParams);
            let best_x = [...current_x], best_cost = current_cost;

            for (let i = 0; i < maxSteps; i++) {
                let neighbor_x = current_x.map((val, idx) => {
                    let newVal = val + (Math.random() - 0.5) * paramMapping[idx].step * 2 * T;
                    if (paramMapping[idx].name.includes('eta')) newVal = Math.max(0, Math.min(1, newVal));
                    else if (['a1','a2','b1','b2','c1','c2','a_shared','b_shared','c_shared', 'GW', 'LX'].includes(paramMapping[idx].name)) newVal = Math.max(0.001, newVal);
                    return newVal;
                });
                let neighbor_cost = objective(neighbor_x, initialParams);
                if (neighbor_cost < current_cost || Math.exp(-(neighbor_cost - current_cost) / T) > Math.random()) {
                    current_x = [...neighbor_x]; current_cost = neighbor_cost;
                }
                if (current_cost < best_cost) { best_x = [...current_x]; best_cost = current_cost; }
                T *= coolingRate;
                if (progressCallback && i % Math.floor(maxSteps/100) === 0) {
                    await progressCallback(i / maxSteps, null);
                }
            }
            if(progressCallback) await progressCallback(1, null);

            let finalParams = JSON.parse(JSON.stringify(initialParams));
            paramMapping.forEach((m, i) => m.set(finalParams, best_x[i]));
            return { params: finalParams, algorithm: 'sa', paramMapping, fitFlags, constraints };
        }
        

        async function refineParametersLM(initialParams, fitFlags, constraints, maxIter, progressCallback, workingData, total_intensity_for_weights) {
            const { paramMapping } = getParameterMapping(fitFlags, constraints);
            if (paramMapping.length === 0) return { params: initialParams, algorithm: 'lm', paramMapping, fitFlags, constraints };

            let params = JSON.parse(JSON.stringify(initialParams));
            let lambda = 0.001;

            // --- CHANGE IS HERE: Use the total intensity for stable weights ---
            const weights = total_intensity_for_weights.map(y => 1 / Math.max(y, 1));
            // --- END CHANGE ---
            
            const maxTth = Math.max(...workingData.tth);
            
            const calculateResiduals = (p_vec, current_params) => {
                let tempParams = JSON.parse(JSON.stringify(current_params));
                paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));

                let hkl1 = generateHKL(maxTth, tempParams.phase1, tempParams.phase1.system, tempParams.phase1.centering, 'P1');
                let hkl2 = generateHKL(maxTth, tempParams.phase2, tempParams.phase2.system, tempParams.phase2.centering, 'P2');
                let combined = hkl1.concat(hkl2).sort((a,b)=>a.tth-b.tth);
                
                // Note: Intensity extraction still uses the net data (workingData)
                leBailIntensityExtraction(workingData, combined, tempParams);
                const netPattern = calculateNetPattern(workingData.tth, combined, tempParams);
                return subtract(workingData.intensity, netPattern);
            };
            
            let last_cost = Infinity, JtJ;
            for (let iter = 0; iter < maxIter; iter++) {
                let p_current_vec = paramMapping.map(m => m.get(params));
                const residuals = calculateResiduals(p_current_vec, params);
                const weightedResiduals = residuals.map((r, i) => r * Math.sqrt(weights[i]));
                const cost = dot(weightedResiduals, weightedResiduals);

                if (Math.abs(last_cost - cost) < 1e-9 * cost && iter > 0) break;
                last_cost = cost;

                const jacobian = paramMapping.map((m,i) => {
                    const p_plus = [...p_current_vec]; p_plus[i] += m.step;
                    const res_plus = calculateResiduals(p_plus, params);
                    const weighted_res_plus = res_plus.map((r, j) => r * Math.sqrt(weights[j]));
                    return scale(subtract(weighted_res_plus, weightedResiduals), -1 / m.step).map(v => isFinite(v) ? v: 0);
                });
                
                const J = transpose(jacobian);
                JtJ = multiply(transpose(J), J);
                const Jtr = multiply(transpose(J), weightedResiduals);
                const A_lm = JSON.parse(JSON.stringify(JtJ));
                for (let i=0; i < A_lm.length; i++) A_lm[i][i] += lambda * (A_lm[i][i] || 1.0);
                const p_step = solve(A_lm, Jtr);
                if (p_step.some(isNaN)) break;

                const p_new_vec = add(p_current_vec, p_step);
                const new_residuals = calculateResiduals(p_new_vec, params);
                const new_cost = dot(new_residuals.map((r, i) => r * Math.sqrt(weights[i])), new_residuals.map((r, i) => r * Math.sqrt(weights[i])));
                
                if (new_cost < cost && isFinite(new_cost)) {
                    paramMapping.forEach((m, i) => m.set(params, p_new_vec[i]));
                    lambda = Math.max(lambda / 2, 1e-9);
                } else {
                    lambda = Math.min(lambda * 2, 1e9);
                }
                if (progressCallback) await progressCallback((iter + 1) / maxIter, null);
            }
            return { params, JtJ, ss_res: last_cost, algorithm: 'lm', paramMapping, fitFlags, constraints };
        }

        function updatePreviewPattern() {
            if (!mainChart || fullExperimentalData.tth.length === 0 || isFitting) return;
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            ['Calculated', 'Difference', 'Simulation (Manual)'].forEach(label => { const ds = findDataset(label); if(ds) ds.data = []; });
            
            let params = getAllParams();
            const constraints = getConstraints();
            Object.keys(constraints).forEach(key => {
                const p = key.replace('constrain_', '');
                if (constraints[key] && params.phase1[p] !== undefined) params.phase2[p] = params.phase1[p];
            });

            const maxTth = Math.max(...fullExperimentalData.tth);
            const hklList1 = generateHKL(maxTth, params.phase1, params.phase1.system, params.phase1.centering, 'P1');
            const hklList2 = generateHKL(maxTth, params.phase2, params.phase2.system, params.phase2.centering, 'P2');
            lastGeneratedHklList = hklList1.concat(hklList2).sort((a, b) => a.tth - b.tth);
            
            const arbitraryIntensity = Math.max(...fullExperimentalData.intensity) * 0.5;
            lastGeneratedHklList.forEach(p => p.intensity = arbitraryIntensity);
            
            const netPattern = calculateNetPattern(fullExperimentalData.tth, lastGeneratedHklList, params);
            const totalSimPattern = netPattern.map((y, i) => y + (calculatedBackground[i] || 0));

            findDataset('Simulation (Manual)').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: totalSimPattern[i]}));
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: calculatedBackground[i]}));
            
            const yMax = mainChart.options.scales.y.max / 1.1;
            const markerBarHeight = yMax * 0.04;
            const p1_top_y = -yMax * 0.02;
            const p2_top_y = -yMax * 0.08;

            findDataset('HKL P1').data = hklList1.map(hkl => ({ x: hkl.tth + params.zeroShift, y: [p1_top_y - markerBarHeight, p1_top_y] }));
            findDataset('HKL P2').data = hklList2.map(hkl => ({ x: hkl.tth + params.zeroShift, y: [p2_top_y - markerBarHeight, p2_top_y] }));
            
            mainChart.update('none');
        }

        function setUIState(fitting) {
            isFitting = fitting;
            controls.fitButton.disabled = fitting;
            controls.reportButton.disabled = fitting;
            controls.saveDataButton.disabled = fitting;
            controls.fitButton.textContent = fitting ? 'Refining...' : 'Run Refinement';
            controls.progressBarContainer.classList.toggle('hidden', !fitting);
            document.body.style.cursor = fitting ? 'wait' : 'default';
            if (fitting) { 
                controls.rpResult.textContent = '...';
                controls.rwpResult.textContent = '...';
                controls.chi2Result.textContent = '...';
            }
            if (!fitting) {
                controls.progressBar.style.width = '0%';
                if (fitResults) {
                    controls.reportButton.disabled = false;
                    controls.saveDataButton.disabled = false;
                }
            }
        }
        
        function updateUI(params, stats, scaledPeakPattern, background) {
            if (stats.r_p !== undefined) controls.rpResult.textContent = stats.r_p.toFixed(4);
            if (stats.rwp !== undefined) controls.rwpResult.textContent = stats.rwp.toFixed(4);
            if (stats.chi2 !== undefined) controls.chi2Result.textContent = stats.chi2.toFixed(4);

            const setVal = (pName, pIdx, val, digits) => {
                const el = document.getElementById(`lattice-param-${pName}-p${pIdx}`);
                if (el && val != null && isFinite(val)) el.value = val.toFixed(digits);
            };
            const p1 = params.phase1, p2 = params.phase2;
            ['a', 'b', 'c'].forEach(p => { setVal(p, 1, p1[p], 5); setVal(p, 2, p2[p], 5); });
            ['alpha', 'beta', 'gamma'].forEach(p => { setVal(p, 1, p1[p], 4); setVal(p, 2, p2[p], 4); });

            controls.zeroShift.value = params.zeroShift.toFixed(4);
            controls.paramGU.value = params.GU.toFixed(4); controls.paramGV.value = params.GV.toFixed(4);
            controls.paramGW.value = params.GW.toFixed(4); controls.paramGP.value = params.GP.toFixed(4);
            controls.paramLX.value = params.LX.toFixed(4); controls.paramEta.value = params.eta.toFixed(4);
            controls.paramShft.value = params.shft.toFixed(4); controls.paramTrns.value = params.trns.toFixed(4);
            
            if (scaledPeakPattern && background) {
                const maxTth = Math.max(...fullExperimentalData.tth);
                const hklList1 = generateHKL(maxTth, params.phase1, params.phase1.system, params.phase1.centering, 'P1');
                const hklList2 = generateHKL(maxTth, params.phase2, params.phase2.system, params.phase2.centering, 'P2');
                updateChart(scaledPeakPattern, background, hklList1, hklList2, params);
            }
        }

        function initializeChart() {
            if (mainChart) mainChart.destroy();
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line', data: { datasets: [
                    { label: 'Experimental', data: fullExperimentalData.tth.map((t, i) => ({x: t, y: fullExperimentalData.intensity[i]})), borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 1.5, pointRadius: 0, order: 1 },
                    { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                    { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                    { label: 'Background', data: [], borderColor: 'rgba(217, 119, 6, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                    { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                    { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                    { type: 'bar', label: 'HKL P1', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 1.5, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                    { type: 'bar', label: 'HKL P2', data: [], backgroundColor: 'rgba(126, 34, 206, 0.9)', barThickness: 1.5, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 }
                ]},
                options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { 
                    x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                    y: { type: 'linear', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }}, min: -yMax * 0.3, max: Math.ceil(yMax * 1.1), ticks: { callback: v => v >= 0 ? v.toFixed(0) : null }}
                }, plugins: {
                    zoom: { pan: { enabled: true, mode: 'xy', threshold: 5 }, zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }}},
                    legend: { labels: { filter: item => !['Difference Zero', 'Simulation (Manual)'].includes(item.text) }}, 
                    tooltip: { enabled: true, mode: 'index', intersect: false, position: 'nearest' } 
                } }
            });
        }
        
        function updatePlotRange() {
            if(!mainChart || !fullExperimentalData || fullExperimentalData.tth.length === 0) return;
            const min = parseFloat(controls.tthMinSlider.value); const max = parseFloat(controls.tthMaxSlider.value);
            mainChart.options.scales.x.min = min; mainChart.options.scales.x.max = max;
            let yMaxInRange = 1; 
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max && fullExperimentalData.intensity[i] > yMaxInRange) yMaxInRange = fullExperimentalData.intensity[i];
            }
            mainChart.options.scales.y.max = Math.ceil(yMaxInRange * 1.1);
            mainChart.options.scales.y.min = -yMaxInRange * 0.33;
        }

        function updateChart(scaledPeakPattern, background, hklList1, hklList2, params) {
            if (!mainChart) return;
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            findDataset('Simulation (Manual)').data = []; 
            
            const totalCalcPattern = scaledPeakPattern.map((y, i) => y + background[i]);
            findDataset('Calculated').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: totalCalcPattern[i]})); 
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: background[i]})); 
            
            lastRawDifference = fullExperimentalData.intensity.map((y, i) => y - totalCalcPattern[i]);
            updatePlotRange();
            const yMax = mainChart.options.scales.y.max / 1.1;

            let dYmax = 1;
            const min = parseFloat(controls.tthMinSlider.value); const max = parseFloat(controls.tthMaxSlider.value);
            for (let i = 0; i < fullExperimentalData.tth.length; i++) if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
            
            const diffPlotOffset = -yMax * (0.33 / 2);
            const scalingFactor = (yMax * (0.33 / 2) * 0.9) / dYmax;

            findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotOffset }));
            findDataset('Difference Zero').data = [{x: fullExperimentalData.tth[0], y: diffPlotOffset}, {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotOffset}];

            const markerBarHeight = yMax * 0.04;
            const p1_top_y = -yMax * 0.02;
            const p2_top_y = -yMax * 0.08;

            findDataset('HKL P1').data = hklList1.map(hkl => ({ x: hkl.tth + params.zeroShift, y: [p1_top_y - markerBarHeight, p1_top_y] }));
            findDataset('HKL P2').data = hklList2.map(hkl => ({ x: hkl.tth + params.zeroShift, y: [p2_top_y - markerBarHeight, p2_top_y] }));

            mainChart.update('none');
        }

        controls.fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
        try {
            // Use the new, more robust detection function
            const parsedData = detectAndParseFile(file.name, evt.target.result);
            
            if (!parsedData || !parsedData.tth || parsedData.tth.length === 0) {
                throw new Error("No valid data points could be parsed from the file.");
            }

            // Update wavelength if the file contains it
            if (parsedData.wavelength) {
                controls.wavelength.value = parsedData.wavelength.toFixed(5);
            }
            
            // --- The rest of this is standard setup for misfit.html ---
            fullExperimentalData = { tth: parsedData.tth, intensity: parsedData.intensity };
            lastRawDifference = []; 
            calculatedBackground = new Array(fullExperimentalData.tth.length).fill(0);

            // Normalize intensity
            const maxExpIntensity = Math.max(...fullExperimentalData.intensity);
            if (maxExpIntensity > 0) {
                fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => (y / maxExpIntensity) * 1000);
            }

            // Update UI elements
            controls.fileName.textContent = file.name;
            document.getElementById('placeholder').classList.add('hidden');
            document.getElementById('results-container').classList.remove('hidden');
            controls.fitButton.disabled = false; 
            controls.fitButton.textContent = 'Run Refinement';

            // Initialize chart and sliders
            initializeChart();
            const min = fullExperimentalData.tth[0];
            const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
            const step = (max - min) / 2000;

            [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                slider.min = min;
                slider.max = max;
                slider.step = step;
                slider.disabled = false;
            });
            controls.tthMinSlider.value = Math.max(min, 10);
            controls.tthMaxSlider.value = Math.min(max, 100);
            controls.tthMinValue.textContent = parseFloat(controls.tthMinSlider.value).toFixed(1); 
            controls.tthMaxValue.textContent = parseFloat(controls.tthMaxSlider.value).toFixed(1);
            
            // Perform initial background calculation and plot update
            updateAndApplyBackground();
            updatePlotRange();
            updatePreviewPattern();

        } catch (error) {
            // Use alert() for errors
            alert(`Error reading file: ${error.message}`);
            console.error(error);
        }
    };
    reader.onerror = () => { alert('Error: Could not read the selected file.'); };
    reader.readAsText(file);
});


        document.getElementById('controls-panel').addEventListener('input', (event) => {
            const target = event.target;
            const targetId = target.id;
            if ((target.tagName === 'INPUT' || target.tagName === 'SELECT') && !['file-input', 'tth-min-slider', 'tth-max-slider', 'iterations-slider', 'ball-radius-slider', 'smoothing-width-slider'].includes(targetId)) {
                handleParameterSync(target);
                updatePreviewPattern();
            }
        });

        function handleParameterSync(target) {
            const id = target.id;
            if (!id.startsWith('lattice-param-') && !id.startsWith('fit-lattice-')) return;
            const parts = id.split('-'), paramName = parts[2], phase = parts[3];
            const constraintCheckbox = document.getElementById(`constraint-${paramName}`);
            if (constraintCheckbox && constraintCheckbox.checked) {
                const otherPhase = (phase === 'p1') ? 'p2' : 'p1';
                if (id.startsWith('lattice-param-')) {
                    const destEl = document.getElementById(`lattice-param-${paramName}-${otherPhase}`);
                    if (destEl) destEl.value = target.value;
                } else {
                    const destEl = document.getElementById(`fit-lattice-${paramName}-${otherPhase}`);
                    if (destEl) destEl.checked = target.checked;
                }
            }
        }

        function updateConstraintStates() {
            ['a', 'b', 'c', 'alpha', 'beta', 'gamma'].forEach(pName => {
                const cBox = document.getElementById(`constraint-${pName}`);
                const p1Val = document.getElementById(`lattice-param-${pName}-p1`), p1Fit = document.getElementById(`fit-lattice-${pName}-p1`);
                const p2Val = document.getElementById(`lattice-param-${pName}-p2`), p2Fit = document.getElementById(`fit-lattice-${pName}-p2`);
                if (cBox && p1Val && p2Val && p1Fit && p2Fit) {
                     if (cBox.checked) {
                        p2Val.value = p1Val.value; p2Fit.checked = p1Fit.checked;
                        p2Val.disabled = true; p2Fit.disabled = true;
                    } else { p2Val.disabled = false; p2Fit.disabled = false; }
                }
            });
        }
        
        function rescalePlot() {
            if (!mainChart || !fullExperimentalData.tth.length) return;
            
            updatePlotRange(); 

            if (lastRawDifference && lastRawDifference.length > 0) {
                const yMax = mainChart.options.scales.y.max / 1.1;

                let dYmax = 1;
                const min = parseFloat(controls.tthMinSlider.value);
                const max = parseFloat(controls.tthMaxSlider.value);
                for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                    if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) {
                        dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
                    }
                }
                const diffPlotOffset = -yMax * (0.33 / 2);
                const scalingFactor = (yMax * (0.33 / 2) * 0.9) / dYmax;
                
                const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
                findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotOffset }));
                findDataset('Difference Zero').data = [{x: fullExperimentalData.tth[0], y: diffPlotOffset}, {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotOffset}];

                const markerBarHeight = yMax * 0.04;
                const p1_top_y = -yMax * 0.02;
                const p2_top_y = -yMax * 0.08;
                findDataset('HKL P1').data.forEach(point => point.y = [p1_top_y - markerBarHeight, p1_top_y]);
                findDataset('HKL P2').data.forEach(point => point.y = [p2_top_y - markerBarHeight, p2_top_y]);
            }

            mainChart.update('none');
        }

        controls.fitButton.addEventListener('click', runLeBailFit);
        document.querySelector('.tab-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-btn')) {
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active'));
                document.getElementById(`tab-panel-${e.target.dataset.tab}`).classList.add('active');
            }
        });
        
        const resizer = document.getElementById('drag-handle');
        resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize';
            const moveHandler = (me) => { if (me.clientX > 350 && me.clientX < window.innerWidth-350) document.getElementById('controls-panel').style.width = `${me.clientX}px`; };
            const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
            window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler);
        });
        

        
        controls.saveDataButton.addEventListener('click', () => {
            if (!fitResults) {
                alert("Please run a refinement before saving data.");
                return;
            }
            const originalText = controls.saveDataButton.textContent;
            controls.saveDataButton.textContent = 'Saving...';
            controls.saveDataButton.disabled = true;
            try {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const baseFilename = `Misfit-Report-${timestamp}`;
                const textContent = generateTextReportContent(fitResults, controls);
                downloadTextFile(textContent, `${baseFilename}.txt`);
            } catch (error) {
                console.error("Failed to save data:", error);
                alert("An error occurred while saving the data file.");
            } finally {
                controls.saveDataButton.textContent = 'Save Report';
                controls.saveDataButton.disabled = false;
            }
        });


        controls.reportButton.addEventListener('click', async () => {
            if (!fitResults) {
                alert("Please run a refinement before generating a report.");
                return;
            }
            const originalText = controls.reportButton.textContent;
            controls.reportButton.textContent = 'Generating...';
            controls.reportButton.disabled = true;

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const margin = 15;
                const pdfWidth = doc.internal.pageSize.getWidth();
                let yPos = 20;

                const addHeader = (text, size=11) => { yPos += 4; doc.setFont('Helvetica', 'bold'); doc.setFontSize(size); doc.text(text, margin, yPos); yPos += 7; doc.setFont('Courier', 'normal'); doc.setFontSize(9); };
                const addLine = (text) => { doc.text(text, margin, yPos); yPos += 5; if (yPos > 280) { doc.addPage(); yPos = 20; }};

                // Page 1: Chart and Main Results
                doc.setFontSize(18);
                doc.text('Misfit Le Bail Refinement Report', pdfWidth / 2, 15, { align: 'center' });
                const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff' });
                const mainImgData = chartCanvas.toDataURL('image/png');
                const mainImgProps = doc.getImageProperties(mainImgData);
                const mainImgHeight = (mainImgProps.height * (pdfWidth - 2 * margin)) / mainImgProps.width;
                doc.addImage(mainImgData, 'PNG', margin, 25, pdfWidth - 2 * margin, mainImgHeight);
                yPos = 35 + mainImgHeight;

                addHeader('Refinement Statistics', 12);
                addLine(`Rp (%):      ${fitResults.stats.r_p.toFixed(4)}`);
                addLine(`Rwp (%):     ${fitResults.stats.rwp.toFixed(4)}`);
                addLine(`Chi2 (GOF):  ${fitResults.stats.chi2.toFixed(4)}`);
                
                doc.addPage();
                yPos = 20;
                
                // Page 2: Parameters
                addHeader('Refined Parameters', 14);
                let esds = {};
                let esdWarning = null;
                if (fitResults.algorithm === 'lm' && fitResults.JtJ) {
                    const workingDataForStats = getWorkingData(true);
                    const N = workingDataForStats.intensity.length;
                    const P = fitResults.paramMapping.length;
                    if (N > P && fitResults.ss_res !== undefined) {
                        const reduced_chi_sq = fitResults.ss_res / (N - P);
                        const cov_matrix = matrixInverse(fitResults.JtJ);
                        if (cov_matrix) {
                            fitResults.paramMapping.forEach((p, i) => {
                                if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                    esds[p.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i]));
                                }
                            });
                        } else {
                            esdWarning = "ESD calculation failed: matrix is singular (correlated parameters).";
                        }
                    }
                }

                const paramTableLine = (name, value, flag, esdKey, constraintInfo = '') => {
                    const valStr = (value !== undefined && value !== null) ? value.toExponential(5) : 'N/A';
                    let fitStr = flag ? 'Yes' : (constraintInfo ? constraintInfo : 'No');
                    if (typeof flag === 'string') fitStr = flag;
                    
                    let esdStr = '-';
                     if (fitResults.algorithm === 'lm' && (flag === true || constraintInfo)) {
                        esdStr = (esds[esdKey] !== undefined) ? `(${esds[esdKey].toExponential(2)})` : '(failed)';
                    }
                    addLine(`${name.padEnd(14)}${valStr.padStart(14)} ${fitStr.padStart(8)}   ${esdStr.padStart(15)}`);
                };
                
                const { params: finalParams, fitFlags } = fitResults;
                const constraints = getConstraints();
                
                addLine('Parameter'.padEnd(14) + 'Value'.padStart(14) + ' ' + 'Fitted'.padStart(8) + '   ' + 'Std. Error (ESD)'.padStart(15));
                addLine('-'.repeat(70));
                
                doc.setFont('Helvetica', 'bold'); doc.text('Phase 1:', margin, yPos); yPos += 6; doc.setFont('Courier', 'normal');
                ['a','b','c','alpha','beta','gamma'].forEach(p => {
                    if (finalParams.phase1[p]) paramTableLine(`${p}`, finalParams.phase1[p], fitFlags.phase1[p], constraints[`constrain_${p}`] ? `${p}_shared` : `${p}1`);
                });
                yPos += 3;

                doc.setFont('Helvetica', 'bold'); doc.text('Phase 2:', margin, yPos); yPos += 6; doc.setFont('Courier', 'normal');
                ['a','b','c','alpha','beta','gamma'].forEach(p => {
                     if (finalParams.phase2[p]) {
                        const isConstrained = constraints[`constrain_${p}`];
                        paramTableLine(`${p}`, finalParams.phase2[p], isConstrained ? '(constr.)' : fitFlags.phase2[p], isConstrained ? `${p}_shared` : `${p}2`);
                    }
                });
                yPos += 3;

                doc.setFont('Helvetica', 'bold'); doc.text('Shared & Profile:', margin, yPos); yPos += 6; doc.setFont('Courier', 'normal');
                ['zeroShift','GU','GV','GW','GP','LX','eta','shft','trns'].forEach(p => {
                    paramTableLine(p, finalParams[p], fitFlags[p], p);
                });
                
                if (esdWarning) {
                    yPos += 5;
                    doc.setTextColor(255, 0, 0);
                    doc.text(esdWarning, margin, yPos);
                    doc.setTextColor(0, 0, 0);
                }

                // Reflections list starts on a new page for clarity
                doc.addPage();
                yPos = 20;

                addHeader('Calculated vs. Experimental Reflections', 14);
                const textContentForHkl = generateTextReportContent(fitResults, controls);
                const hklLines = textContentForHkl.split('\n').filter(line => /^(P1|P2)/.test(line.trim()));
                const hklHeader = 'Phase  h,k,l         d_calc (Å)    d_exp (Å)     2th_corr (°)    2th_exp (°)';
                
                const printHklHeader = () => { addLine(hklHeader); addLine('-'.repeat(90)); };
                printHklHeader();

                hklLines.forEach(line => {
                    if (yPos > 280) { doc.addPage(); yPos = 20; printHklHeader(); }
                    addLine(line);
                });

                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                doc.save(`Misfit-Report-${timestamp}.pdf`);

            } catch (error) {
                console.error("Failed to generate report:", error);
                alert("An error occurred while generating the report.");
            } finally {
                controls.reportButton.textContent = 'Generate PDF';
                controls.reportButton.disabled = false;
            }
        });
       
       
       
        controls.iterationsSlider.addEventListener('input', () => { controls.iterationsValue.textContent = controls.iterationsSlider.value; });
        
        controls.tthMinSlider.addEventListener('input', () => {
            let minVal = parseFloat(controls.tthMinSlider.value), maxVal = parseFloat(controls.tthMaxSlider.value);
            if (minVal >= maxVal) { minVal = maxVal - parseFloat(controls.tthMinSlider.step); controls.tthMinSlider.value = minVal; }
            controls.tthMinValue.textContent = minVal.toFixed(1);
            rescalePlot();
        });
        controls.tthMaxSlider.addEventListener('input', () => {
            let minVal = parseFloat(controls.tthMinSlider.value), maxVal = parseFloat(controls.tthMaxSlider.value);
            if (maxVal <= minVal) { maxVal = minVal + parseFloat(controls.tthMaxSlider.step); controls.tthMaxSlider.value = maxVal; }
            controls.tthMaxValue.textContent = maxVal.toFixed(1);
            rescalePlot();
        });
        
        controls.bravaisLatticeP1.addEventListener('change', () => { updateLatticeParamUI(1); updateAvailableConstraints(); updatePreviewPattern(); });
        controls.bravaisLatticeP2.addEventListener('change', () => { updateLatticeParamUI(2); updateAvailableConstraints(); updatePreviewPattern(); });
        controls.constraintsContainer.addEventListener('change', (e) => { if(e.target.classList.contains('constraint-checkbox')) { updateConstraintStates(); updatePreviewPattern(); } });
        
        controls.ballRadiusSlider.addEventListener('input', () => { controls.ballRadiusValue.textContent = controls.ballRadiusSlider.value; updateAndApplyBackground(); });
        controls.smoothingWidthSlider.addEventListener('input', () => { controls.smoothingWidthValue.textContent = controls.smoothingWidthSlider.value; updateAndApplyBackground(); });
        
        controls.mainChartCanvas.addEventListener('wheel', e => {
            e.preventDefault(); const chart = mainChart; if (!chart || !chart.chartArea) return;
            const { left, right, top, bottom } = chart.chartArea; const x = e.offsetX, y = e.offsetY;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            if (y > bottom) chart.zoom({ x: zoomFactor }, { x, y });
            else if (x < left) chart.zoom({ y: zoomFactor }, { x, y });
            else if (x >= left && x <= right && y >= top && y <= bottom) chart.zoom({ x: zoomFactor, y: zoomFactor }, { x, y });
        });
        controls.mainChartCanvas.addEventListener('contextmenu', e => { e.preventDefault(); if (mainChart) mainChart.resetZoom(); });
        
        // --- Initial Setup ---
        updateLatticeParamUI(1);
        updateLatticeParamUI(2);
        updateConstraintsUI();
        updateAvailableConstraints();
    });
</script>
</body>
</html>